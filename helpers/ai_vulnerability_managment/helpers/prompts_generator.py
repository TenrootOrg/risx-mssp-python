import openai
import re
import time
import json
from json_repair import repair_json
import datetime

from helpers.ai_vulnerability_managment.apis.gemini import GeminiAPI
from helpers.ai_vulnerability_managment.apis.gpt import ChatGPTAPI
from helpers.ai_vulnerability_managment.apis.claude import ClaudeAPI

def get_llm_api(general_settings, logger):
    """
    Factory function to get the appropriate LLM API client based on vendor_name.
    """
    logger.info("general settings:" + str(general_settings))
    vendor = general_settings['VENDOR_NAME'].lower()
    logger.info("Vendor:" + vendor)
    if vendor == "chatgpt":
        logger.info("Using ChatGPT API")
        return ChatGPTAPI(general_settings, logger)
    elif vendor == "claude":
        logger.info("Using Claude API")
        return ClaudeAPI(general_settings, logger)
    elif vendor == "gemini":
        logger.info("Using Gemini API")
        return GeminiAPI(general_settings, logger)
    else:
        error_msg = f"Unsupported vendor: {vendor}"
        logger.error(error_msg)
        raise ValueError(error_msg)
    
MAX_TOKENS = 4096  # Ensure model can accept a lot of tokens

def extract_json_from_gpt(text):
    # Try to find JSON object within the response, even if surrounded by markdown or other text
    pattern = r'(?s)^.*?(\{.*\}).*$'  # Match JSON object inside the text
    match = re.search(pattern, text)
    if match:
        try:
            json_text = match.group(1)
            return json.loads(json_text)
        except json.JSONDecodeError:
            return None
    return None


#line 63 {batch}
def products_list_to_cpe_dict(llm_api_client, general_settings, product_list, logger, prompt_logger):
    # First, generalize the product names to improve matching
    generalized_products = generalize_product_names(product_list, logger)
    
    # Split the product list into batches of 10
    batch_size = 10
    product_batches = [generalized_products[i:i + batch_size] for i in range(0, len(generalized_products), batch_size)]
    
    combined_results = {}
    
    prompt_logger.info("Getting CPE json object [To use in NVD]:\n")
    prompt_logger.info("---------------------------------------------------")
    system_prompt = """You are a specialized vulnerability analyst with expertise in the National Vulnerability Database (NVD) and Common Platform Enumeration (CPE) formats. Your role is to accurately convert software and hardware product names into valid CPE 2.3 identifiers that will successfully match entries in the NVD database.
When generating CPEs, strictly follow NVD compatibility guidelines. Pay special attention to vendor and product name formats, use hyphens for version fields to indicate "any version," and ensure all CPEs follow the complete URI format. Your output should be concise, accurate, and formatted as valid JSON.
You should focus exclusively on the task of generating valid CPEs without adding explanations or comments. The CPEs you generate must produce results when queried against the NVD API."""
    for batch in product_batches:
        prompt = f"""
        Convert the following software product list into NVD-compatible CPE 2.3 identifiers that will successfully match entries in the National Vulnerability Database API. Use general patterns without specific versions.

        Task: Generate a JSON object where each key is the software name (exactly as provided) and each value is a CPE that will return results when queried against the NVD database.

        CRITICAL CPE CONSTRUCTION RULES:
        1. For version fields, use "-" (hyphen) instead of "*" when indicating "any version" - this is crucial for NVD API compatibility
        2. IMPORTANT: For all applications and operating systems, use generic forms without version numbers:
           - Example: "cpe:2.3:a:google:chrome:-:*:*:*:*:*:*:*" instead of specific Chrome versions
           - Example: "cpe:2.3:a:mozilla:firefox:-:*:*:*:*:*:*:*" instead of specific Firefox versions
        3. For Microsoft Windows products:
           - Windows 11: Use "cpe:2.3:o:microsoft:windows_11:-:*:*:*:*:*:*:*"
           - Windows 10: Use "cpe:2.3:o:microsoft:windows_10:-:*:*:*:*:*:*:*"
           - Windows Server: Use "cpe:2.3:o:microsoft:windows_server:-:*:*:*:*:*:*:*"
        4. For Linux distributions: 
           - Ubuntu: Use "cpe:2.3:o:canonical:ubuntu:-:*:*:*:*:*:*:*"
           - Debian: Use "cpe:2.3:o:debian:debian_linux:-:*:*:*:*:*:*:*"
        5. For all CPEs:
           - Always use hyphen ("-") for version field
           - Check product naming carefully - incorrect product names are the #1 reason for 404 errors
           - Focus on the product name that will match in the NVD database

        Product list to convert:
        {batch}
        
        Return only a properly formatted JSON object with CPEs that will successfully return results from the NVD API.
        """
        prompt_logger.info("Request prompt:\n" + prompt)
        prompt_logger.info("***************************************************")
        # Get response for this batch
        batch_response = llm_api_client.send_request(system_prompt, prompt, temperature=0.7, max_tokens=10000)
        prompt_logger.info("Response:\n" + str(batch_response))
        prompt_logger.info("---------------------------------------------------")
        try:
            # Option 1: If extract_json_from_gpt returns a dictionary
            batch_json_str = batch_response  # The raw response is a string
            
            # Try to repair the JSON string first
            repaired_json_str = repair_json(batch_json_str)
            
            # Then extract the JSON after repair
            batch_dict = extract_json_from_gpt(repaired_json_str)
            
            # Merge with combined results
            combined_results.update(batch_dict)
            
        except Exception as e:
            logger.error(f"Error processing batch: {e}")
            logger.error(f"Problematic batch: {batch}")
            logger.error(f"Raw response: {batch_response[:500]}...")  # Log first 500 chars of the response
            
            # Fallback repair attempt
            try:
                # Try another approach if the first method fails
                raw_json_str = batch_response
                # Find JSON content between triple backticks if present
                import re
                json_match = re.search(r'```json\s*([\s\S]*?)\s*```', raw_json_str)
                
                if json_match:
                    json_content = json_match.group(1)
                    repaired_json = repair_json(json_content)
                    import json
                    batch_dict = json.loads(repaired_json)
                    combined_results.update(batch_dict)
                    logger.info("Successfully recovered JSON with fallback method")
                else:
                    logger.error("Could not find JSON content in the response")
            except Exception as inner_e:
                logger.error(f"Fallback repair also failed: {inner_e}")
            
    return combined_results

def generalize_product_names(product_list, logger):
    """
    Generalizes product names by removing specific version information
    to improve CPE matching.
    
    Args:
        product_list: List of product strings in format "Name Version"
        logger: Logger object for logging messages
        
    Returns:
        list: List of generalized product names
    """
    logger.info("Generalizing product names for better CPE matching")
    
    generalized_list = []
    
    for product in product_list:
        # Skip empty entries
        if not product or product.isspace():
            continue
            
        # Try to split into name and version
        parts = product.split()
        if len(parts) > 1:
            # Join all but the last part as the name (assuming last part is version)
            original_name = " ".join(parts[:-1])
            generalized_list.append(original_name)
            logger.debug(f"Simplified '{product}' to '{original_name}'")
        else:
            # Only one part, so it's already a name without version
            generalized_list.append(product)
            
    # Remove duplicates while preserving order
    unique_list = []
    seen = set()
    for item in generalized_list:
        if item.lower() not in seen:
            unique_list.append(item)
            seen.add(item.lower())
            
    logger.info(f"Generalized {len(product_list)} products into {len(unique_list)} unique general names")
    return unique_list

def fix_operator_object_format(json_data):
    """
    Generic function to recursively process JSON and convert any operator-value object
    to string format for compatibility with Elasticsearch.
    
    Converts objects like {'operator': '>', 'value': 1000000} to '> 1000000'
    Works on any nested JSON structure.
    
    Args:
        json_data: Any JSON data structure (dict, list, or primitive)
        
    Returns:
        Processed data with operator objects converted to strings
    """
    import copy
    
    # Deep copy to avoid modifying the original
    processed_data = copy.deepcopy(json_data)
    
    def process_item(item):
        """Recursively process each item in the JSON structure"""
        # Base case: not a dict or list
        if not isinstance(item, (dict, list)):
            return item
            
        # Case: dict - check for operator/value pattern and process each value
        if isinstance(item, dict):
            # Check if this dict is an operator-value object
            if 'operator' in item and 'value' in item:
                operator = item['operator']
                val = item['value']
                
                # Handle different operator types
                if operator == 'in' and isinstance(val, list):
                    # For 'in' operators with lists, format as "in [val1, val2, ...]"
                    return f"in [{', '.join(str(v) for v in val)}]"
                else:
                    # For other operators, format as "operator value"
                    return f"{operator} {val}"
            
            # Not an operator object, process each value recursively
            return {k: process_item(v) for k, v in item.items()}
            
        # Case: list - process each item in the list
        elif isinstance(item, list):
            return [process_item(element) for element in item]
    
    # Start the recursive processing
    return process_item(processed_data)

# Example of where to add this in the upload function:
def preprocess_cve_for_elasticsearch(cve_data):
    """
    Preprocess CVE data for Elasticsearch compatibility.
    Converts operator objects to strings throughout the entire JSON structure.
    """
    # Process the entire vulnerability structure to fix any operator objects
    return fix_operator_object_format(cve_data)

def enrich_cve_data(llm_api_client, cve_data, general_settings, logger, prompt_logger):
    logger.info("Starting CVE enrichment process")
    logger.info("CVE Data:" + str(cve_data))
    # Get the vulnerabilities from the input dictionary
    vulnerabilities = cve_data.get("vulnerabilities", {})
    
    # Check if we have any vulnerabilities to process
    if not vulnerabilities:
        logger.warning("No vulnerabilities found in input data")
        return cve_data
        
    logger.info(f"Input data contains {len(vulnerabilities)} CVE records")
    
    # Create a copy of the vulnerabilities
    enriched_vulnerabilities = {}
    # epoch_time = time.time()
    now = time.gmtime()
    iso_format = time.strftime("%Y-%m-%dT%H:%M:%S", now) + f".{int(datetime.datetime.utcnow().microsecond / 1000):03d}Z"

    # Copy the vulnerabilities and initialize rule fields
    for cve_id, vuln_data in vulnerabilities.items():
        enriched_vulnerabilities[cve_id] = vuln_data.copy()
        
        # Initialize rule fields with empty objects
        enriched_vulnerabilities[cve_id]["sigma_rules"] = {}
        enriched_vulnerabilities[cve_id]["nuclei_rules"] = {}
        enriched_vulnerabilities[cve_id]["yara_rules"] = {}
        enriched_vulnerabilities[cve_id]["mitigations"] = {}
        enriched_vulnerabilities[cve_id]["known_exploits"] = {}
        enriched_vulnerabilities[cve_id]["run_date"] = iso_format
    
    logger.debug("Initialized rule fields in vulnerabilities")
    
    sigma_prompt_template = """
    For the vulnerability {cve_id} ({description}), please CREATE and GENERATE (not search for existing):
    SIGMA rules for detection of this vulnerability.

    CRITICAL JSON FORMATTING INSTRUCTIONS:
    - Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
    - The response must start with {{ and end with }} without any other characters before or after.
    - Do NOT wrap the response in markdown code blocks (```json).
    - Use the top-level key: "sigma_rules" containing an array of rules
    - For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")

    JSON STRUCTURE EXAMPLE:

    {{
      "sigma_rules": [
        {{
          "title": "Detection of {cve_id}",
          "id": "cve-{cve_id}-detection",
          "status": "experimental",
          "description": "Detects potential exploitation attempts of {cve_id}, a vulnerability in [affected component].",
          "date": "2025-03-19",
          "author": "Security Researcher",
          "logsource": {{
            "category": "process_creation",
            "product": "windows"
          }},
          "detection": {{
            "selection": {{
              "Image": "path/to/vulnerable/binary",
              "CommandLine|contains": "[suspicious pattern]"
            }},
            "condition": "selection"
          }},
          "falsepositives": [
            "Legitimate use cases description"
          ],
          "level": "medium"
        }}
      ]
    }}

    DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
    """

    nuclei_prompt_template = """
    For the vulnerability {cve_id} ({description}), please CREATE and GENERATE (not search for existing):
    Nuclei templates for scanning systems for this vulnerability.

    CRITICAL JSON FORMATTING INSTRUCTIONS:
    - Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
    - The response must start with {{ and end with }} without any other characters before or after.
    - Do NOT wrap the response in markdown code blocks (```json).
    - Use the top-level key: "nuclei_rules" containing an array of rules
    - For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")
    - Matchers MUST use supported fields only. DO NOT include invalid keys like "condition" inside matchers.
    - Use '{{BaseURL}}' in the "path" field to ensure compatibility with Nuclei template engine.

    JSON STRUCTURE EXAMPLE:

    {{
      "nuclei_rules": [
        {{
          "id": "{cve_id}",
          "info": {{
            "name": "[Vulnerability Name]",
            "author": "Security Researcher",
            "severity": "high",
            "description": "Detects [vulnerability description]",
            "tags": [
              "cve",
              "vulnerability-type",
              "affected-system"
            ],
            "reference": [
              "https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}"
            ]
          }},
          "requests": [
            {{
              "method": "GET",
              "path": [
                "{{{{BaseURL}}}}/"
              ],
              "matchers": [
                {{
                  "type": "word",
                  "words": [
                    "vulnerable response pattern"
                  ]
                }}
              ]
            }}
          ]
        }}
      ]
    }}

    DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
    """


    yara_prompt_template = """
    For the vulnerability {cve_id} ({description}), please CREATE and GENERATE (not search for existing):
    YARA rules for detection of this vulnerability.

    CRITICAL JSON FORMATTING INSTRUCTIONS:
    - Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
    - The response must start with {{ and end with }} without any other characters before or after.
    - Do NOT wrap the response in markdown code blocks (```json).
    - Use the top-level key: "yara_rules" containing an array of rules
    - For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")

    JSON STRUCTURE EXAMPLE:

    {{
      "yara_rules": [
        {{
          "rule": "{cve_id}_Detection",
          "meta": {{
            "description": "Detects exploitation attempts of {cve_id}",
            "author": "Security Researcher",
            "date": "2025-03-19",
            "reference": "https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}"
          }},
          "strings": [
            {{
              "id": "$s1",
              "value": "exploit signature pattern 1"
            }},
            {{
              "id": "$s2",
              "value": "exploit signature pattern 2"
            }}
          ],
          "condition": "$s1 and $s2"
        }}
      ]
    }}

    DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
    """

    exploits_prompt_template = """
For the vulnerability {cve_id} ({description}), please SEARCH FOR and REPORT on EXISTING public exploits:
Information about known exploit techniques, exploit availability, and attack groups associated with this vulnerability.

CRITICAL JSON FORMATTING INSTRUCTIONS:
- Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
- The response must start with {{ and end with }} without any other characters before or after.
- Do NOT wrap the response in markdown code blocks (```json).
- Use the top-level key: "known_exploits"
- For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")

JSON STRUCTURE EXAMPLE:

{{
  "known_exploits": {{
    "public_exploits": [
      {{
        "name": "Exploit Name/ID",
        "url": "https://link-to-public-exploit.com/exploit",
        "description": "Brief description of the exploit"
      }}
    ],
    "exploit_availability": "Available/Limited/Not Available",
    "threat_actors": [
      {{
        "name": "Threat Actor/Group Name",
        "activity": "Description of their activity related to this CVE"
      }}
    ],
    "references": [
      "https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}",
      "https://other-relevant-resource.com/cve-details"
    ]
  }}
}}

DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSONÂ object.
"""
    mitigation_prompt_template = """
    For the vulnerability {cve_id} ({description}), please CREATE and GENERATE (not search for existing):
    Detailed mitigation strategies for this vulnerability.

    CRITICAL JSON FORMATTING INSTRUCTIONS:
    - Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
    - The response must start with {{ and end with }} without any other characters before or after.
    - Do NOT wrap the response in markdown code blocks (```json).
    - Use the top-level key: "mitigations" 
    - For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")

    JSON STRUCTURE EXAMPLE:

    {{
      "mitigations": {{
        "strategies": [
          {{
            "name": "Patch Installation",
            "description": "Apply the vendor-provided security patch X.Y.Z",
            "difficulty": "medium",
            "effectiveness": "high"
          }},
          {{
            "name": "Configuration Change",
            "description": "Disable vulnerable feature by modifying configuration at path/to/config",
            "difficulty": "low",
            "effectiveness": "medium"
          }},
          {{
            "name": "Workaround",
            "description": "Implement alternative approach that avoids the vulnerability",
            "difficulty": "medium",
            "effectiveness": "medium"
          }}
        ],
        "recommendations": "Primary recommendation for addressing this vulnerability",
        "references": [
          "https://vendor.com/security-advisory/{cve_id}"
        ]
      }}
    }}

    DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
    """
    logger.debug(f"Using separate prompt templates for each rule type")
    
    # Process each vulnerability
    successful_count = 0
    failed_count = 0
    total_count = len(enriched_vulnerabilities)
    logger.info(f"Starting to process {total_count} CVEs...")
    
    # Convert to list for easier iteration with counters
    items = list(enriched_vulnerabilities.items())
    
    for index, (cve_id, vuln_data) in enumerate(items):
        description = vuln_data.get("description", "No description available")
        
        logger.info(f"Processing CVE {index+1}/{total_count}: {cve_id}")
        logger.debug(f"CVE description: {description}")
        prompt_logger.info("Prompts for " + cve_id)
        prompt_logger.info("---------------------------------------------------")
        # Process each rule type separately
        rule_types = [
            {"name": "sigma_rules", "prompt_template": sigma_prompt_template},
            {"name": "nuclei_rules", "prompt_template": nuclei_prompt_template},
            {"name": "yara_rules", "prompt_template": yara_prompt_template},
            {"name": "mitigations", "prompt_template": mitigation_prompt_template},
            {"name": "known_exploits", "prompt_template": exploits_prompt_template}
        ]
        
        for rule_type in rule_types:
            rule_name = rule_type["name"]
            prompt_template = rule_type["prompt_template"]
            
            # Create the specific prompt for this rule type and CVE
            prompt = prompt_template.format(cve_id=cve_id, description=description)
            logger.debug(f"Generated {rule_name} prompt for {cve_id}")
            
            try:
                # Query GPT API
                logger.info(f"Sending {rule_name} request to GPT API for {cve_id}")
                start_time = time.time()
                prompt_logger.info("Prompt request [" + rule_name + "]:\n" + prompt)
                prompt_logger.info("***************************************************")
                response = llm_api_client.send_request("", prompt, temperature=0.7, max_tokens=2000)
                prompt_logger.info("Prompt response [" + rule_name + "]:\n" + response)
                prompt_logger.info("---------------------------------------------------")
                end_time = time.time()
                
                logger.info(f"Received {rule_name} response from GPT API for {cve_id} in {end_time - start_time:.2f} seconds")
                logger.debug(f"FULL GPT Response for {rule_name}:\n{response}")
                
                # Try standard JSON parsing
                try:
                    # Try direct parsing first
                    try:
                        rules_data = json.loads(repair_json(response))
                    except json.JSONDecodeError:
                        # If that fails, try extracting JSON from the response
                        rules_data = extract_json_from_gpt(repair_json(response))
                        if not rules_data:
                            raise json.JSONDecodeError(f"Could not extract valid JSON for {rule_name}", "", 0)
                    
                    logger.info(f"{rule_name} data: {str(rules_data)}")
                    
                    # Check if the expected key exists in the response
                    if rule_name in rules_data:
                        # Update the vulnerability data with the new rules
                        enriched_vulnerabilities[cve_id][rule_name] = rules_data[rule_name]
                        
                        # Log size of rule data
                        rule_size = len(str(rules_data[rule_name]))
                        logger.info(f"Rule size for {cve_id} {rule_name}: ({rule_size})")
                    else:
                        logger.warning(f"Expected key '{rule_name}' not found in response for {cve_id}")
                        # Keep the initialized empty object
                    
                except Exception as e:
                    error_msg = f"Failed to parse JSON response for {cve_id} {rule_name}: {str(e)}"
                    logger.error(error_msg)
                    logger.error(f"Failed response: {response[:100]}...")
                    # Keep the initialized empty object
            
            except Exception as e:
                error_msg = f"Error processing {cve_id} {rule_name}: {str(e)}"
                logger.error(error_msg)
                # Keep the initialized empty object
            
            # Add delay to avoid rate limiting
            delay_between_requests = general_settings.get("api_delay", 1)
            logger.debug(f"Waiting {delay_between_requests} seconds before next request")
            time.sleep(delay_between_requests)
        
        # Check if all rule types were successfully processed
        if (enriched_vulnerabilities[cve_id]["sigma_rules"] and 
            enriched_vulnerabilities[cve_id]["nuclei_rules"] and 
            enriched_vulnerabilities[cve_id]["yara_rules"] and 
            enriched_vulnerabilities[cve_id]["mitigations"] and
            enriched_vulnerabilities[cve_id]["known_exploits"]):
            successful_count += 1
            logger.info(f"Successfully processed all rule types for {cve_id} ({index+1}/{total_count})")
        else:
            failed_count += 1
            logger.warning(f"Partially processed {cve_id} ({index+1}/{total_count})")
    
    # Log summary statistics
    logger.info("CVE enrichment process completed")
    logger.info(f"Total CVEs processed: {total_count}")
    logger.info(f"Successfully processed all rule types: {successful_count}")
    logger.info(f"Partially or failed to process: {failed_count}")
    
    # Return the enriched vulnerabilities as the result
    result = fix_operator_object_format(enriched_vulnerabilities)
    return result
    #return {"vulnerabilities": result}