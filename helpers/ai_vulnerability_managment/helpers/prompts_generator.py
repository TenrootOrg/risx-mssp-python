import openai
import re
import time
import json
from json_repair import repair_json
import datetime

from helpers.ai_vulnerability_managment.apis.gemini import GeminiAPI
from helpers.ai_vulnerability_managment.apis.gpt import ChatGPTAPI
from helpers.ai_vulnerability_managment.apis.claude import ClaudeAPI

def get_llm_api(general_settings, logger):
    """
    Factory function to get the appropriate LLM API client based on vendor_name.
    """
    logger.info("general settings:" + str(general_settings))
    vendor = general_settings['VENDOR_NAME'].lower()
    logger.info("Vendor:" + vendor)
    if vendor == "chatgpt":
        logger.info("Using ChatGPT API")
        return ChatGPTAPI(general_settings, logger)
    elif vendor == "claude":
        logger.info("Using Claude API")
        return ClaudeAPI(general_settings, logger)
    elif vendor == "gemini":
        logger.info("Using Gemini API")
        return GeminiAPI(general_settings, logger)
    else:
        error_msg = f"Unsupported vendor: {vendor}"
        logger.error(error_msg)
        raise ValueError(error_msg)
    
MAX_TOKENS = 4096  # Ensure model can accept a lot of tokens

def extract_json_from_gpt(text):
    # Try to find JSON object within the response, even if surrounded by markdown or other text
    pattern = r'(?s)^.*?(\{.*\}).*$'  # Match JSON object inside the text
    match = re.search(pattern, text)
    if match:
        try:
            json_text = match.group(1)
            return json.loads(json_text)
        except json.JSONDecodeError:
            return None
    return None


import re
import json

# ==============================================================================
# Main Function to Convert Products to CPEs (with updated dynamic prompt)
# ==============================================================================

def products_list_to_cpe_dict(llm_api_client, general_settings, product_list, logger, prompt_logger):
    """
    Converts a list of product names into a dictionary of NVD-compatible CPEs
    by sending the raw product list directly to the LLM with a robust prompt.
    """
    # Remove duplicates from the initial list while preserving order
    unique_products = list(dict.fromkeys(product_list))
    
    batch_size = 10
    product_batches = [unique_products[i:i + batch_size] for i in range(0, len(unique_products), batch_size)]
    
    combined_results = {}
    
    prompt_logger.info("Getting CPE json object [To use in NVD]:\n")
    prompt_logger.info("---------------------------------------------------")

    # The system prompt instructs the AI on its role and output format.
    system_prompt = """You are an expert vulnerability analyst specializing in NVD and CPE formats. Your task is to convert a list of product names into generic, NVD-compatible CPE 2.3 identifiers. Your output must be a single, valid JSON object without any extra explanations or markdown."""
    
    for batch in product_batches:
        # --- THIS PROMPT IS NOW FULLY DYNAMIC ---
        # It instructs the AI on how to generalize names itself, removing the need for a separate function.
        prompt = f"""
        Convert the following product list into NVD-compatible CPE 2.3 identifiers.

        Task:
        For each product in the list, identify the core product name, ignoring specific version numbers unless the version is part of the official product name (like 'Windows 10'). Then, generate a JSON object where the key is the original product name and the value is the corresponding generic CPE string.

        CRITICAL CPE CONSTRUCTION RULES:
        1.  **Always use a wildcard for the version**: The version field in the CPE string must ALWAYS be a hyphen "-".
        2.  **Handle OSes Correctly**:
            -   Input "Windows 10" -> Identify product "windows_10" -> CPE: "cpe:2.3:o:microsoft:windows_10:-:*:*:*:*:*:*:*"
            -   Input "Windows 11 23H2" -> Identify product "windows_11" -> CPE: "cpe:2.3:o:microsoft:windows_11:-:*:*:*:*:*:*:*"
        3.  **Handle Applications/Drivers Correctly**:
            -   Input "NVIDIA GPU Driver 555.99" -> Identify product "gpu_driver" -> CPE: "cpe:2.3:a:nvidia:gpu_driver:-:*:*:*:*:*:*:*"
            -   Input "Adobe Photoshop 2024" -> Identify product "photoshop" -> CPE: "cpe:2.3:a:adobe:photoshop:-:*:*:*:*:*:*:*"
        4.  **Vendor and Product Names**: Accurately identify the official vendor and product names as used by NVD (e.g., 'microsoft', not 'MS'; 'gpu_driver', not 'gpu driver').
        5.  **Format**: Return ONLY a single, valid JSON object.

        Product list to convert:
        {batch}
        """
        
        prompt_logger.info("Request prompt:\n" + prompt)
        prompt_logger.info("***************************************************")
        
        # Get response for this batch
        batch_response = llm_api_client.send_request(system_prompt, prompt, temperature=0.7, max_tokens=10000)
        
        prompt_logger.info("Response:\n" + str(batch_response))
        prompt_logger.info("---------------------------------------------------")

        try:
            # Attempt to extract and parse the JSON from the response
            batch_dict = extract_json_from_gpt(batch_response)
            if batch_dict:
                combined_results.update(batch_dict)
        except Exception as e:
            logger.error(f"Failed to process and parse response for batch: {batch}. Error: {e}")
            logger.error(f"Raw response was: {batch_response[:500]}")
            # Optional: Add fallback/retry logic here if needed
            
    return combined_results


# ==============================================================================
# Helper function to extract JSON (no changes needed here)
# ==============================================================================

def extract_json_from_gpt(response_text):
    """
    A robust function to find and parse a JSON object from a string,
    even if it's embedded in text or markdown.
    """
    # Find JSON content between triple backticks if present
    json_match = re.search(r'```json\s*([\s\S]*?)\s*```', response_text)
    if json_match:
        json_content = json_match.group(1)
    else:
        # If no markdown, assume the whole string might be JSON or contain it
        # Find the first '{' and last '}'
        start = response_text.find('{')
        end = response_text.rfind('}')
        if start != -1 and end != -1 and end > start:
            json_content = response_text[start:end+1]
        else:
            raise ValueError("No valid JSON object found in the response.")

    try:
        # Here you might call a `repair_json` function if you have one
        return json.loads(json_content)
    except json.JSONDecodeError as e:
        raise ValueError(f"Failed to parse extracted JSON: {e}") from e

def fix_operator_object_format(json_data):
    """
    Generic function to recursively process JSON and convert any operator-value object
    to string format for compatibility with Elasticsearch.
    
    Converts objects like {'operator': '>', 'value': 1000000} to '> 1000000'
    Works on any nested JSON structure.
    
    Args:
        json_data: Any JSON data structure (dict, list, or primitive)
        
    Returns:
        Processed data with operator objects converted to strings
    """
    import copy
    
    # Deep copy to avoid modifying the original
    processed_data = copy.deepcopy(json_data)
    
    def process_item(item):
        """Recursively process each item in the JSON structure"""
        # Base case: not a dict or list
        if not isinstance(item, (dict, list)):
            return item
            
        # Case: dict - check for operator/value pattern and process each value
        if isinstance(item, dict):
            # Check if this dict is an operator-value object
            if 'operator' in item and 'value' in item:
                operator = item['operator']
                val = item['value']
                
                # Handle different operator types
                if operator == 'in' and isinstance(val, list):
                    # For 'in' operators with lists, format as "in [val1, val2, ...]"
                    return f"in [{', '.join(str(v) for v in val)}]"
                else:
                    # For other operators, format as "operator value"
                    return f"{operator} {val}"
            
            # Not an operator object, process each value recursively
            return {k: process_item(v) for k, v in item.items()}
            
        # Case: list - process each item in the list
        elif isinstance(item, list):
            return [process_item(element) for element in item]
    
    # Start the recursive processing
    return process_item(processed_data)
    
# Example of where to add this in the upload function:
def preprocess_cve_for_elasticsearch(cve_data):
    """
    Preprocess CVE data for Elasticsearch compatibility.
    Converts operator objects to strings throughout the entire JSON structure.
    """
    # Process the entire vulnerability structure to fix any operator objects
    return fix_operator_object_format(cve_data)

def enrich_cve_data(llm_api_client, cve_data, general_settings, logger, prompt_logger):
    logger.info("Starting CVE enrichment process")
    logger.info("CVE Data:" + str(cve_data))
    # Get the vulnerabilities from the input dictionary
    vulnerabilities = cve_data.get("vulnerabilities", {})
    
    # Check if we have any vulnerabilities to process
    if not vulnerabilities:
        logger.warning("No vulnerabilities found in input data")
        return cve_data
        
    logger.info(f"Input data contains {len(vulnerabilities)} CVE records")
    
    # Create a copy of the vulnerabilities
    enriched_vulnerabilities = {}
    # epoch_time = time.time()
    now = time.gmtime()
    iso_format = time.strftime("%Y-%m-%dT%H:%M:%S", now) + f".{int(datetime.datetime.utcnow().microsecond / 1000):03d}Z"

    # Copy the vulnerabilities and initialize rule fields
    for cve_id, vuln_data in vulnerabilities.items():
        enriched_vulnerabilities[cve_id] = vuln_data.copy()
        
        # Initialize rule fields with empty objects
        enriched_vulnerabilities[cve_id]["sigma_rules"] = {}
        enriched_vulnerabilities[cve_id]["nuclei_rules"] = {}
        enriched_vulnerabilities[cve_id]["yara_rules"] = {}
        enriched_vulnerabilities[cve_id]["mitigations"] = {}
        enriched_vulnerabilities[cve_id]["known_exploits"] = {}
        enriched_vulnerabilities[cve_id]["run_date"] = iso_format
    
    logger.debug("Initialized rule fields in vulnerabilities")
    
    sigma_prompt_template = """
    For the vulnerability {cve_id} ({description}), please CREATE and GENERATE (not search for existing):
    SIGMA rules for detection of this vulnerability.

    CRITICAL JSON FORMATTING INSTRUCTIONS:
    - Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
    - The response must start with {{ and end with }} without any other characters before or after.
    - Do NOT wrap the response in markdown code blocks (```json).
    - Use the top-level key: "sigma_rules" containing an array of rules
    - For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")

    JSON STRUCTURE EXAMPLE:

    {{
      "sigma_rules": [
        {{
          "title": "Detection of {cve_id}",
          "id": "cve-{cve_id}-detection",
          "status": "experimental",
          "description": "Detects potential exploitation attempts of {cve_id}, a vulnerability in [affected component].",
          "date": "2025-03-19",
          "author": "Security Researcher",
          "logsource": {{
            "category": "process_creation",
            "product": "windows"
          }},
          "detection": {{
            "selection": {{
              "Image": "path/to/vulnerable/binary",
              "CommandLine|contains": "[suspicious pattern]"
            }},
            "condition": "selection"
          }},
          "falsepositives": [
            "Legitimate use cases description"
          ],
          "level": "medium"
        }}
      ]
    }}

    DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
    """

    nuclei_prompt_template = """
    For the vulnerability {cve_id} ({description}), please CREATE and GENERATE (not search for existing):
    Nuclei templates for scanning systems for this vulnerability.

    CRITICAL JSON FORMATTING INSTRUCTIONS:
    - Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
    - The response must start with {{ and end with }} without any other characters before or after.
    - Do NOT wrap the response in markdown code blocks (```json).
    - Use the top-level key: "nuclei_rules" containing an array of rules
    - For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")
    - Matchers MUST use supported fields only. DO NOT include invalid keys like "condition" inside matchers.
    - Use '{{BaseURL}}' in the "path" field to ensure compatibility with Nuclei template engine.

    JSON STRUCTURE EXAMPLE:

    {{
      "nuclei_rules": [
        {{
          "id": "{cve_id}",
          "info": {{
            "name": "[Vulnerability Name]",
            "author": "Security Researcher",
            "severity": "high",
            "description": "Detects [vulnerability description]",
            "tags": [
              "cve",
              "vulnerability-type",
              "affected-system"
            ],
            "reference": [
              "https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}"
            ]
          }},
          "requests": [
            {{
              "method": "GET",
              "path": [
                "{{{{BaseURL}}}}/"
              ],
              "matchers": [
                {{
                  "type": "word",
                  "words": [
                    "vulnerable response pattern"
                  ]
                }}
              ]
            }}
          ]
        }}
      ]
    }}

    DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
    """


    yara_prompt_template = """
    For the vulnerability {cve_id} ({description}), please CREATE and GENERATE (not search for existing):
    YARA rules for detection of this vulnerability.

    CRITICAL JSON FORMATTING INSTRUCTIONS:
    - Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
    - The response must start with {{ and end with }} without any other characters before or after.
    - Do NOT wrap the response in markdown code blocks (```json).
    - Use the top-level key: "yara_rules" containing an array of rules
    - For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")

    JSON STRUCTURE EXAMPLE:

    {{
      "yara_rules": [
        {{
          "rule": "{cve_id}_Detection",
          "meta": {{
            "description": "Detects exploitation attempts of {cve_id}",
            "author": "Security Researcher",
            "date": "2025-03-19",
            "reference": "https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}"
          }},
          "strings": [
            {{
              "id": "$s1",
              "value": "exploit signature pattern 1"
            }},
            {{
              "id": "$s2",
              "value": "exploit signature pattern 2"
            }}
          ],
          "condition": "$s1 and $s2"
        }}
      ]
    }}

    DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
    """

    exploits_prompt_template = """
For the vulnerability {cve_id} ({description}), please SEARCH FOR and REPORT on EXISTING public exploits:
Information about known exploit techniques, exploit availability, and attack groups associated with this vulnerability.

CRITICAL JSON FORMATTING INSTRUCTIONS:
- Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
- The response must start with {{ and end with }} without any other characters before or after.
- Do NOT wrap the response in markdown code blocks (```json).
- Use the top-level key: "known_exploits"
- For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")

JSON STRUCTURE EXAMPLE:

{{
  "known_exploits": {{
    "public_exploits": [
      {{
        "name": "Exploit Name/ID",
        "url": "https://link-to-public-exploit.com/exploit",
        "description": "Brief description of the exploit"
      }}
    ],
    "exploit_availability": "Available/Limited/Not Available",
    "threat_actors": [
      {{
        "name": "Threat Actor/Group Name",
        "activity": "Description of their activity related to this CVE"
      }}
    ],
    "references": [
      "https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}",
      "https://other-relevant-resource.com/cve-details"
    ]
  }}
}}

DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSONÂ object.
"""
    mitigation_prompt_template = """
    For the vulnerability {cve_id} ({description}), please CREATE and GENERATE (not search for existing):
    Detailed mitigation strategies for this vulnerability.

    CRITICAL JSON FORMATTING INSTRUCTIONS:
    - Your ENTIRE response must be a SINGLE, valid JSON object with NO comments, NO explanation text, and NO extra whitespace at the beginning or end.
    - The response must start with {{ and end with }} without any other characters before or after.
    - Do NOT wrap the response in markdown code blocks (```json).
    - Use the top-level key: "mitigations" 
    - For any date fields, use ISO format with dashes: "2025-03-19" (not "2025/03/19")

    JSON STRUCTURE EXAMPLE:

    {{
      "mitigations": {{
        "strategies": [
          {{
            "name": "Patch Installation",
            "description": "Apply the vendor-provided security patch X.Y.Z",
            "difficulty": "medium",
            "effectiveness": "high"
          }},
          {{
            "name": "Configuration Change",
            "description": "Disable vulnerable feature by modifying configuration at path/to/config",
            "difficulty": "low",
            "effectiveness": "medium"
          }},
          {{
            "name": "Workaround",
            "description": "Implement alternative approach that avoids the vulnerability",
            "difficulty": "medium",
            "effectiveness": "medium"
          }}
        ],
        "recommendations": "Primary recommendation for addressing this vulnerability",
        "references": [
          "https://vendor.com/security-advisory/{cve_id}"
        ]
      }}
    }}

    DO NOT include any explanations, markdown formatting, code blocks, or extra text. ONLY return the pure JSON object.
    """
    logger.debug(f"Using separate prompt templates for each rule type")
    
    # Process each vulnerability
    successful_count = 0
    failed_count = 0
    total_count = len(enriched_vulnerabilities)
    logger.info(f"Starting to process {total_count} CVEs...")
    
    # Convert to list for easier iteration with counters
    items = list(enriched_vulnerabilities.items())
    
    for index, (cve_id, vuln_data) in enumerate(items):
        description = vuln_data.get("description", "No description available")
        
        logger.info(f"Processing CVE {index+1}/{total_count}: {cve_id}")
        logger.debug(f"CVE description: {description}")
        prompt_logger.info("Prompts for " + cve_id)
        prompt_logger.info("---------------------------------------------------")
        # Process each rule type separately
        rule_types = [
            {"name": "sigma_rules", "prompt_template": sigma_prompt_template},
            {"name": "nuclei_rules", "prompt_template": nuclei_prompt_template},
            {"name": "yara_rules", "prompt_template": yara_prompt_template},
            {"name": "mitigations", "prompt_template": mitigation_prompt_template},
            {"name": "known_exploits", "prompt_template": exploits_prompt_template}
        ]
        
        for rule_type in rule_types:
            rule_name = rule_type["name"]
            prompt_template = rule_type["prompt_template"]
            
            # Create the specific prompt for this rule type and CVE
            prompt = prompt_template.format(cve_id=cve_id, description=description)
            logger.debug(f"Generated {rule_name} prompt for {cve_id}")
            
            try:
                # Query GPT API
                logger.info(f"Sending {rule_name} request to GPT API for {cve_id}")
                start_time = time.time()
                prompt_logger.info("Prompt request [" + rule_name + "]:\n" + prompt)
                prompt_logger.info("***************************************************")
                response = llm_api_client.send_request("", prompt, temperature=0.7, max_tokens=2000)
                prompt_logger.info("Prompt response [" + rule_name + "]:\n" + response)
                prompt_logger.info("---------------------------------------------------")
                end_time = time.time()
                
                logger.info(f"Received {rule_name} response from GPT API for {cve_id} in {end_time - start_time:.2f} seconds")
                logger.debug(f"FULL GPT Response for {rule_name}:\n{response}")
                
                # Try standard JSON parsing
                try:
                    # Try direct parsing first
                    try:
                        rules_data = json.loads(repair_json(response))
                    except json.JSONDecodeError:
                        # If that fails, try extracting JSON from the response
                        rules_data = extract_json_from_gpt(repair_json(response))
                        if not rules_data:
                            raise json.JSONDecodeError(f"Could not extract valid JSON for {rule_name}", "", 0)
                    
                    logger.info(f"{rule_name} data: {str(rules_data)}")
                    
                    # Check if the expected key exists in the response
                    if rule_name in rules_data:
                        # Update the vulnerability data with the new rules
                        enriched_vulnerabilities[cve_id][rule_name] = rules_data[rule_name]
                        
                        # Log size of rule data
                        rule_size = len(str(rules_data[rule_name]))
                        logger.info(f"Rule size for {cve_id} {rule_name}: ({rule_size})")
                    else:
                        logger.warning(f"Expected key '{rule_name}' not found in response for {cve_id}")
                        # Keep the initialized empty object
                    
                except Exception as e:
                    error_msg = f"Failed to parse JSON response for {cve_id} {rule_name}: {str(e)}"
                    logger.error(error_msg)
                    logger.error(f"Failed response: {response[:100]}...")
                    # Keep the initialized empty object
            
            except Exception as e:
                error_msg = f"Error processing {cve_id} {rule_name}: {str(e)}"
                logger.error(error_msg)
                # Keep the initialized empty object
            
            # Add delay to avoid rate limiting
            delay_between_requests = general_settings.get("api_delay", 1)
            logger.debug(f"Waiting {delay_between_requests} seconds before next request")
            time.sleep(delay_between_requests)
        
        # Check if all rule types were successfully processed
        if (enriched_vulnerabilities[cve_id]["sigma_rules"] and 
            enriched_vulnerabilities[cve_id]["nuclei_rules"] and 
            enriched_vulnerabilities[cve_id]["yara_rules"] and 
            enriched_vulnerabilities[cve_id]["mitigations"] and
            enriched_vulnerabilities[cve_id]["known_exploits"]):
            successful_count += 1
            logger.info(f"Successfully processed all rule types for {cve_id} ({index+1}/{total_count})")
        else:
            failed_count += 1
            logger.warning(f"Partially processed {cve_id} ({index+1}/{total_count})")
    
    # Log summary statistics
    logger.info("CVE enrichment process completed")
    logger.info(f"Total CVEs processed: {total_count}")
    logger.info(f"Successfully processed all rule types: {successful_count}")
    logger.info(f"Partially or failed to process: {failed_count}")
    
    # Return the enriched vulnerabilities as the result
    result = fix_operator_object_format(enriched_vulnerabilities)
    return result
    #return {"vulnerabilities": result}